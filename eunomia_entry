#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import json
import sys
from datetime import datetime
from os import path

import sh

from eunomia.arch.wasm.configuration import Configuration
from eunomia.arch.wasm.graph import Graph
from eunomia.arch.wasm.utils import extract_mapping


def main():
    parser = argparse.ArgumentParser(
        description='Eunomia, a symbolic execution engine for Wasm module')

    inputs = parser.add_argument_group('Input arguments')
    inputs.add_argument('-f', '--file',
                        type=argparse.FileType('rb'),
                        help='binary file (.wasm)',
                        metavar='WASMMODULE', required=True)
    inputs.add_argument(
        '--source_type', default='c', const='c', nargs='?', choices=['c',
                                                                     'go'],
        help='type of source file, used by library function emulator')
    inputs.add_argument('--dsl',
                        action='store',
                        type=str,
                        help='The path of your DSL file')
    inputs.add_argument('--solver',
                        default='z3',
                        const='z3',
                        nargs='?',
                        choices=['z3', 'lab'],
                        help='the adopted backend SMT-solver, z3 is default')
    inputs.add_argument('--stdin',
                        action='store',
                        type=str,
                        help='The stream of stdin')
    inputs.add_argument(
        '--sym_stdin', type=int, nargs=1,
        help="The stream of stdin with N chars")
    inputs.add_argument('--args',
                        action='store',
                        type=str,
                        help='The args that run the to be analyzed program')
    inputs.add_argument(
        '--sym_args', type=int, nargs='+',
        help="Replace the argument by a symbolic argument with length N")

    features = parser.add_argument_group('Features')
    features.add_argument(
        '-v', '--verbose', action='store_true',
        help='switch the logging to debug level')
    features.add_argument(
        '-y', '--analytic', action='store_true',
        help='print Functions instructions analytics')
    features.add_argument(
        '-g', '--cfg', action='store_true',
        help='generate the control flow graph (CFG) (instruction level)')
    features.add_argument(
        '-c', '--call', action='store_true',
        help='generate the call flow graph (function level)')
    features.add_argument(
        '--manual_guide', action='store_true',
        help='allow users to manually guide the control flow')
    features.add_argument(
        '--concrete_globals', action='store_true',
        help='concretize values for globals despite the function is exported')
    features.add_argument(
        '--algo', default='interval', const='interval', nargs='?',
        choices=['dfs', 'interval'],
        help='choose an algorithm to traverse, default is dfs')
    features.add_argument(
        '--stdin_file', type=argparse.FileType('rb'),
        help='file to be read adopts fd_read wasi syscall',
        metavar='STDIN_FILE')
    features.add_argument(
        '--coverage', action='store_true',
        help='calculate the instruction coverage')

    # vulnerability detector
    lasers = parser.add_argument_group('Lasers')
    lasers.add_argument(
        '--overflow', action='store_true',
        help="fire the integer overflow vulnerability detector")
    lasers.add_argument(
        '--divzero', action='store_true',
        help="fire the div-zero vulnerability detector")
    lasers.add_argument(
        '--buffer', action='store_true',
        help="fire the buffer overflow vulnerability detector")

    analyze = parser.add_mutually_exclusive_group(required=False)
    analyze.add_argument(
        '-s', '--symbolic', action='store_true',
        help='perform the symbolic execution')

    graph = parser.add_argument_group('Graph options')
    graph.add_argument('--simplify', action='store_true',
                       help='generate a simplify CFG')
    graph.add_argument('--functions', action='store_true',
                       help='create subgraph for each function')
    graph.add_argument(
        '--onlyfunc', type=str, nargs=1, default=[],
        help='only generate the CFG for this list of function name',
        required=True)

    args = parser.parse_args()

    octo_bytecode = None
    octo_cfg = None
    func_index_to_func_name = None

    # the verbose
    Configuration.set_verbose_flag(args.verbose)

    # retrieve the corresponding wat file
    # and extract the function index to function readable name's mapping
    wat_file_path = args.file.name.replace('.wasm', '.wat')
    if not path.exists(wat_file_path):
        try:
            cmd = sh.Command('wasm2wat')
            cmd_option = [args.file.name, "-o", wat_file_path]
            cmd(cmd_option)
        except Exception:
            raise("There is no corresponding wat file, and the auto generation process is terminated unexpectedly.\nPlease try it manually.")
    func_index_to_func_name = extract_mapping(wat_file_path)
    Configuration.set_func_index_to_func_name(func_index_to_func_name)

    # process input file
    Configuration.set_file(args.file.name)
    octo_bytecode = args.file.read()

    # if user pass the dsl file path
    user_dsl = []
    if args.dsl:
        assert path.exists(args.dsl), f"DSL file ({args.dsl}) does not exist"
        python_cmd = sh.Command('python3')
        cmd = ['./DSL/parser.py', args.dsl]
        python_cmd(cmd)

        # after parse, load the json
        with open(args.dsl + ".json") as fp:
            user_dsl = json.load(fp)

    if args.stdin_file:
        import eunomia.arch.wasm.vmstate
        eunomia.arch.wasm.vmstate.STDIN_BYTES = args.stdin_file.read()

    # Control Flow Analysis & Call flow Analysis
    if args.cfg or args.call or args.analytic:
        from eunomia.analysis.graph import CFGGraph
        from eunomia.arch.wasm.cfg import WasmCFG

        octo_cfg = WasmCFG(octo_bytecode)

        if args.call:
            octo_cfg.visualize_call_flow(
                Configuration.get_func_index_to_func_name())
        if args.analytic:
            octo_cfg.visualize_instrs_per_funcs()

        if args.cfg:
            octo_graph = CFGGraph(octo_cfg)
            if args.functions or args.onlyfunc:
                octo_graph.view_functions(only_func_name=args.onlyfunc,
                                          simplify=args.simplify
                                          )
            else:
                octo_graph.view(simplify=args.simplify)

    # import necessary library
    from eunomia.arch.wasm.emulator import WasmSSAEmulatorEngine
    if args.symbolic:
        Configuration.set_entry(args.onlyfunc)
        Configuration.set_coverage(args.coverage)
        Configuration.set_lasers(args.overflow, args.divzero, args.buffer)
        Configuration.set_source_type(args.source_type)
        Configuration.set_algo(args.algo)
        Configuration.set_concrete_globals(args.concrete_globals)
        Configuration.set_solver(args.solver)
        # --stdin and --sym_stdin cannot exist at the same time
        if args.stdin and args.sym_stdin:
            raise Exception(
                "The --stdin and --sym_stdin cannot exist at the same time")
        if args.stdin:
            Configuration.set_stdin_buffer(args.stdin)
        elif args.sym_stdin:
            Configuration.set_stdin_buffer(args.sym_stdin)

        with open(f'./result/{Configuration.get_file_name()}_{Configuration.get_start_time()}.log', 'a') as fp:
            fp.write("Running command:\n")
            fp.write(" ".join(sys.argv) + "\n")

        # --args and --sym_args can exist simultaneously
        # --args is usually used as argv[0], and --sym_args are the following argv
        # their order are fixed, i.e., --args is in front of --sym_args
        Configuration.set_args(args.args, args.sym_args)

        wasmVM = WasmSSAEmulatorEngine(octo_bytecode)
        # run the emulator for SSA
        Graph.wasmVM = wasmVM
        Graph.manual_guide = args.manual_guide
        Graph.initialize()
        Graph.parse_dsl(user_dsl)
        graph = Graph()
        graph.traverse()

    if not (args.symbolic or args.cfg or args.call or args.analytic):
        parser.print_help()


if __name__ == '__main__':
    job_start_time = datetime.now()
    current_time_start = job_start_time.strftime("%Y-%m-%d %H:%M:%S")
    print(f"Start to analyze: {current_time_start}")
    Configuration.set_start_time(current_time_start)

    main()

    job_end_time = datetime.now()
    current_time_end = job_end_time.strftime("%Y-%m-%d %H:%M:%S")
    print(f"End of analyze: {current_time_end}")
    elapsed_time = job_end_time - job_start_time
    print(f"Time elapsed: {elapsed_time}")
